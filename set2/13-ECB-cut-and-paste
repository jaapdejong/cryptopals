#!/usr/bin/python

# ECB cut-and-paste
# Write a k=v parsing routine, as if for a structured cookie. The routine should take:
# 
# foo=bar&baz=qux&zap=zazzle
# ... and produce:
# 
# {
#   foo: 'bar',
#   baz: 'qux',
#   zap: 'zazzle'
# }
# (you know, the object; I don't care if you convert it to JSON).
# 
# Now write a function that encodes a user profile in that format, given an email address. You should have something like:
# 
# profile_for("foo@bar.com")
# ... and it should produce:
# 
# {
#   email: 'foo@bar.com',
#   uid: 10,
#   role: 'user'
# }
# ... encoded as:
# 
# email=foo@bar.com&uid=10&role=user
# Your "profile_for" function should not allow encoding metacharacters (& and =). Eat them, quote them, whatever you want to do, but don't let people set their email address to "foo@bar.com&role=admin".
# 
# Now, two more easy functions. Generate a random AES key, then:
# 
# Encrypt the encoded user profile under the key; "provide" that to the "attacker".
# Decrypt the encoded user profile and parse it.
# Using only the user input to profile_for() (as an oracle to generate "valid" ciphertexts) and the ciphertexts themselves, make a role=admin profile.

def s2json(s):
	result = "{"
	pairs = s.split("&")
	n = len(pairs)
	for pair in pairs:
		keyValue = pair.split("=")
		if len(keyValue) > 1:
			assert len(keyValue) == 2
			result += "\n  " + keyValue[0] + ": '" + keyValue[1] + "'"
			n -= 1
			if n != 0:
				result += ","
	result += "\n}"
	return result

assert s2json("")                           == "{\n}"
assert s2json("foo")                        == "{\n}"
assert s2json("foo=")                       == "{\n  foo: ''\n}"
assert s2json("foo=&")                      == "{\n  foo: '',\n}"
assert s2json("foo=bar")                    == "{\n  foo: 'bar'\n}"
assert s2json("foo=bar&")                   == "{\n  foo: 'bar',\n}"
assert s2json("foo=bar&baz")                == "{\n  foo: 'bar',\n}"
assert s2json("foo=bar&baz=")               == "{\n  foo: 'bar',\n  baz: ''\n}"
assert s2json("foo=bar&baz=qux")            == "{\n  foo: 'bar',\n  baz: 'qux'\n}"
assert s2json("foo=bar&baz=qux&")           == "{\n  foo: 'bar',\n  baz: 'qux',\n}"
assert s2json("foo=bar&baz=qux&zap")        == "{\n  foo: 'bar',\n  baz: 'qux',\n}"
assert s2json("foo=bar&baz=qux&zap=")       == "{\n  foo: 'bar',\n  baz: 'qux',\n  zap: ''\n}"
assert s2json("foo=bar&baz=qux&zap=zazzle") == "{\n  foo: 'bar',\n  baz: 'qux',\n  zap: 'zazzle'\n}"

def json2s(s):				# "{\n  foo: 'bar',\n  baz: 'qux',\n  zap: 'zazzle'\n}" 
	s = s.replace("{\n  ", "")	# --> "foo: 'bar',\n  baz: 'qux',\n  zap: 'zazzle'\n}"
	s = s.replace("'\n}", "")	# --> "foo: 'bar',\n  baz: 'qux',\n  zap: 'zazzle"
	s = s.replace("',\n  ", "&")	# --> "foo: 'bar&baz: 'qux&zap: 'zazzle"
	s = s.replace(": '", "=")	# --> "foo=bar&baz=qux&zap=zazzle"
	return s
	
assert json2s("{\n  foo: 'bar'\n}") == "foo=bar"
assert json2s("{\n  foo: 'bar',\n  baz: 'qux'\n}") == "foo=bar&baz=qux"
assert json2s("{\n  foo: 'bar',\n  baz: 'qux',\n  zap: 'zazzle'\n}") == "foo=bar&baz=qux&zap=zazzle"

