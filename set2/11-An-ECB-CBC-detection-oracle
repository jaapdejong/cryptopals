#!/usr/bin/python

# An ECB/CBC detection oracle
# Now that you have ECB and CBC working:
# 
# Write a function to generate a random AES key; that's just 16 random bytes.
# 
# Write a function that encrypts data under an unknown key --- that is, a function that generates a random key and encrypts under it.
# 
# The function should look like:
# 
# encryption_oracle(your-input)
# => [MEANINGLESS JIBBER JABBER]
# Under the hood, have the function append 5-10 bytes (count chosen randomly) before the plaintext and 5-10 bytes after the plaintext.
# 
# Now, have the function choose to encrypt under ECB 1/2 the time, and under CBC the other half (just use random IVs each time for CBC). Use rand(2) to decide which to use.
# 
# Detect the block cipher mode the function is using each time. You should end up with a piece of code that, pointed at a block box that might be encrypting ECB or CBC, tells you which one is happening.

hexString2string = lambda s: s.decode("hex")
string2hexString = lambda s: s.encode("hex")
stringStringXor = lambda s1, s2: ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(s1, s2))

from Crypto.Cipher import AES
pad = lambda s, l: s + (l - len(s) % l) * chr(l - len(s) % l)
unpad = lambda s: s[:-ord(s[-1:])]
encodeECB = lambda key, s: AES.new(key).encrypt(pad(s, len(key)))
decodeECB = lambda key, s: unpad(AES.new(key).decrypt(s))

BLOCKSIZE = 16
def decodeCBC(key, IV, cipherText):
	plainText = ''
	offset = 0
	aes = AES.new(key)
	while offset < len(cipherText):
		cipherBlock = cipherText[offset:offset+BLOCKSIZE]
		ecbBlock = aes.decrypt(cipherBlock)
		plainBlock = stringStringXor(ecbBlock, IV)
		plainText += plainBlock
		IV = cipherBlock
		offset += BLOCKSIZE

	# strip off padding bytes
	plainText = plainText[:-ord(plainText[-1:])]
	return plainText

def encodeCBC(key, IV, plainText):
	cipherText = ''
	offset = 0
	aes = AES.new(key)
	while offset < len(plainText):
		plainBlock = plainText[offset:offset+BLOCKSIZE]
		# add padding
		if len(plainBlock) < BLOCKSIZE:
			c = BLOCKSIZE - len(plainBlock)
			plainBlock += chr(c) * c
		ecbBlock = stringStringXor(plainBlock, IV)
		cipherBlock = aes.encrypt(ecbBlock)
		cipherText += cipherBlock
		IV = cipherBlock
		offset += BLOCKSIZE

	# add padding if last byte exactly on BLOCKSIZE boundary
	if offset == len(plainText):
		c = BLOCKSIZE
		plainBlock = chr(c) * c
		ecbBlock = stringStringXor(plainBlock, IV)
		cipherBlock = aes.encrypt(ecbBlock)
		cipherText += cipherBlock

	return cipherText

key = "1234567890123456"
IV = "ABCDEFGHIJKLMNOP"
assert decodeCBC(key, IV, encodeCBC(key, IV,"YELLOW SUBMARI")) == "YELLOW SUBMARI"
assert decodeCBC(key, IV, encodeCBC(key, IV,"YELLOW SUBMARIN")) == "YELLOW SUBMARIN"
assert decodeCBC(key, IV, encodeCBC(key, IV,"YELLOW SUBMARINE")) == "YELLOW SUBMARINE"
assert decodeCBC(key, IV, encodeCBC(key, IV,"YELLOW SUBMARINES")) == "YELLOW SUBMARINES"
assert decodeCBC(key, IV, encodeCBC(key, IV,"YELLOW SUBMARINES!")) == "YELLOW SUBMARINES!"

def hammingDistance(s1, s2):
	x = stringStringXor(s1, s2)

	# count 1's
	diffs = 0
	for i in range(0, len(x)):
		a = ord(x[i])
		while a != 0:
			if a % 2 == 1:
				diffs += 1
			a /= 2
	return diffs

assert hammingDistance("this is a test","wokka wokka!!!") == 37

def bestKeyLength(s):
	bestDistance = None
	bestKeyLength = None
	end = min(len(s), 80)
	for keyLength in range(2, end):
		totalDistance = 0
		chunks = len(s) / keyLength
		for n in range(0, chunks):
			s1 = s[n * keyLength:(n + 1) * keyLength]
			s2 = s[(n + 1) * keyLength:(n + 2) * keyLength]
			totalDistance += hammingDistance(s1, s2)
		distance = totalDistance * 1.0 / chunks / keyLength
		if bestDistance == None or bestDistance > distance:
			bestDistance = distance
			bestKeyLength = keyLength

	return bestKeyLength

assert bestKeyLength("123456789012345678901234567801234567") == 29

from random import randint
def randomString(n):
	result =""
	for x in range(0, n):
		result += chr(randint(0, 255))
	return result
	
def encryptionOracle(data):
	data = randomString(randint(5, 10)) + data + randomString(randint(5, 10))
	key = randomString(BLOCKSIZE)
	encryptMode = randint(0, 1)
	print "encrypted with",
	if encryptMode == 0:
		print "ECB -->",
		return encodeECB(key, data)
	else:
		print "CBC -->",
		IV = randomString(BLOCKSIZE)
		return encodeCBC(key, IV, data)
		
def detectEncryption(encryptedData):
	keyLength = bestKeyLength(encryptedData)
	if keyLength <= BLOCKSIZE * 3 and keyLength % BLOCKSIZE == 0:
		print "ECB",
	else:
		print "CBC",
	print "assumed", keyLength

plainText = "YELLOW SUBMARINE" * 50

for i in range(1, 20):
	encryptedData = encryptionOracle(plainText)
	detectEncryption(encryptedData)
	



